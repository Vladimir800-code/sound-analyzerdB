<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>–ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–≤—É–∫–∞ (–¥–ë SPL)</title>
<style>
  :root { --blue:#2563eb; --blue-dark:#1e40af; --grid:#e5e7eb; --text:#111827; --muted:#6b7280; }
  * { box-sizing: border-box; }
  body {
    font-family: Arial, sans-serif;
    color: var(--text);
    background: linear-gradient(to bottom, #f0f4f8, #dbeafe);
    margin: 0; padding: 0; text-align: center;
  }
  header { padding: 18px 12px 6px; }
  h1 { margin: 0 0 8px; color:#1e3a8a; font-size: 22px; }
  .controls { margin: 8px 0 4px; display:flex; gap:8px; justify-content:center; flex-wrap: wrap; }
  button {
    padding: 10px 16px; font-size: 15px; border: none; border-radius: 10px;
    background: var(--blue); color:#fff; cursor:pointer; transition: background .25s ease, transform .05s ease;
  }
  button:hover { background: var(--blue-dark); }
  button:active { transform: translateY(1px); }
  button:disabled { background:#94a3b8; cursor: not-allowed; }
  #status { min-height: 22px; font-weight: 600; margin: 8px 0 0; color:#0f172a; }
  #status.error { color:#b91c1c; }
  #status.ok { color:#065f46; }
  #status.processing { color:#1e40af; }
  main { padding: 10px 12px 30px; }
  canvas {
    display:block; margin: 12px auto 0; background:#fff; border:1px solid #000;
    max-width: 95vw; height:auto;
  }
  .hint { color: var(--muted); font-size: 13px; margin-top: 6px; }
  .permission-note {
    background: #fffbeb;
    border: 1px solid #fcd34d;
    border-radius: 8px;
    padding: 12px;
    margin: 12px auto;
    max-width: 500px;
    font-size: 14px;
    color: #92400e;
  }
</style>
</head>
<body>
<header>
  <h1>–ê–Ω–∞–ª–∏–∑ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏ –∑–≤—É–∫–∞ (–¥–ë SPL)</h1>
  <div class="permission-note">
    ‚ö† –î–ª—è —Ä–∞–±–æ—Ç—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É.<br>
    –†–∞–∑—Ä–µ—à–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –≤ –±—Ä–∞—É–∑–µ—Ä–µ.
  </div>
  <div class="controls">
    <button id="calibrateBtn">üìè –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞</button>
    <button id="startBtn">üéô –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å (10 —Å)</button>
    <button id="resetCalBtn" title="–£–¥–∞–ª–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—É—é –∫–∞–ª–∏–±—Ä–æ–≤–∫—É">‚ôªÔ∏è –°–±—Ä–æ—Å –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏</button>
  </div>
  <div id="status" aria-live="polite"></div>
  <div class="hint">–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ ¬´–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞¬ª. –í–∞—à–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –±—Ä–∞—É–∑–µ—Ä–µ (localStorage).</div>
</header>
<main>
  <canvas id="graph" width="900" height="420"></canvas>
</main>

<script>
(() => {
  const startBtn = document.getElementById('startBtn');
  const calibrateBtn = document.getElementById('calibrateBtn');
  const resetCalBtn = document.getElementById('resetCalBtn');
  const status = document.getElementById('status');
  const canvas = document.getElementById('graph');
  const ctx = canvas.getContext('2d');

  const DURATION = 10;
  const CHUNK_SIZE = 1024;
  const NOISE_RECORD_DURATION = 2;
  let audioData = [];
  let noiseProfile = [];
  let noiseRMS = 0;

  let audioContext = null;
  let sourceNode = null;
  let scriptProcessor = null;
  let currentStream = null;
  let recordTimer = null;
  let isRecording = false;
  let hasMicrophoneAccess = false;

  let K = parseFloat(localStorage.getItem('calibrationK') || 'NaN');
  if (isFinite(K) && K > 0) {
    setStatus('–ù–∞–π–¥–µ–Ω–∞ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–∞—è –∫–∞–ª–∏–±—Ä–æ–≤–∫–∞.', 'ok');
  } else {
    K = NaN;
    setStatus('–ù–∞–∂–º–∏—Ç–µ "–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞" –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã.', '');
  }

  function setStatus(text, cls='') {
    status.className = cls ? cls : '';
    status.textContent = text;
  }

  function setButtonsDisabled(disabled) {
    startBtn.disabled = disabled;
    calibrateBtn.disabled = disabled;
    resetCalBtn.disabled = disabled && !isFinite(K);
  }

  function getRMS(arr) {
    if (!arr || arr.length === 0) return 0;
    let s = 0;
    for (let i = 0; i < arr.length; i++) s += arr[i] * arr[i];
    return Math.sqrt(s / arr.length);
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ –∑–∞–ø—Ä–æ—Å–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É
  async function requestMicrophoneAccess() {
    if (hasMicrophoneAccess) return true;
    
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      setStatus('‚ùå –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä–∞–±–æ—Ç—É —Å –º–∏–∫—Ä–æ—Ñ–æ–Ω–æ–º.', 'error');
      return false;
    }

    try {
      setStatus('üîç –ó–∞–ø—Ä–æ—Å –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É...', 'processing');
      
      // –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          sampleRate: 44100
        }
      });
      
      // –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Ç–æ–∫ –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–∞
      stream.getTracks().forEach(track => track.stop());
      
      hasMicrophoneAccess = true;
      setStatus('‚úÖ –î–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –ø–æ–ª—É—á–µ–Ω', 'ok');
      return true;
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É:', error);
      let errorMessage = '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É. ';
      
      if (error.name === 'NotAllowedError') {
        errorMessage += '–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –±—Ä–∞—É–∑–µ—Ä–∞.';
      } else if (error.name === 'NotFoundError') {
        errorMessage += '–ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω.';
      } else if (error.name === 'NotReadableError') {
        errorMessage += '–ú–∏–∫—Ä–æ—Ñ–æ–Ω —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥—Ä—É–≥–∏–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º.';
      } else {
        errorMessage += error.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞.';
      }
      
      setStatus(errorMessage, 'error');
      return false;
    }
  }

  async function recordNoiseProfile(duration) {
    return new Promise((resolve) => {
      setStatus('üîç –ó–∞–ø–∏—Å—å —Ñ–æ–Ω–æ–≤–æ–≥–æ —à—É–º–∞...', 'processing');
      
      const noiseData = [];
      const tempScriptProcessor = audioContext.createScriptProcessor(CHUNK_SIZE, 1, 1);
      tempScriptProcessor.onaudioprocess = (event) => {
        const input = event.inputBuffer.getChannelData(0);
        noiseData.push(...input);
      };
      
      sourceNode.connect(tempScriptProcessor);
      tempScriptProcessor.connect(audioContext.destination);
      
      setTimeout(() => {
        tempScriptProcessor.disconnect();
        tempScriptProcessor.onaudioprocess = null;
        
        noiseRMS = getRMS(noiseData);
        
        const chunkCount = Math.floor(noiseData.length / CHUNK_SIZE);
        noiseProfile = new Array(CHUNK_SIZE).fill(0);
        
        for (let i = 0; i < chunkCount; i++) {
          const chunk = noiseData.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
          for (let j = 0; j < CHUNK_SIZE; j++) {
            noiseProfile[j] += Math.abs(chunk[j]) / chunkCount;
          }
        }
        
        setStatus('‚úÖ –ü—Ä–æ—Ñ–∏–ª—å —à—É–º–∞ –∑–∞–ø–∏—Å–∞–Ω', 'ok');
        resolve();
      }, duration * 1000);
    });
  }

  function denoiseSignal(signal) {
    if (!noiseProfile.length || noiseRMS < 1e-6) return signal;
    
    const cleanedSignal = new Float32Array(signal.length);
    const chunks = Math.ceil(signal.length / CHUNK_SIZE);
    
    for (let i = 0; i < chunks; i++) {
      const start = i * CHUNK_SIZE;
      const end = Math.min(start + CHUNK_SIZE, signal.length);
      const chunk = signal.slice(start, end);
      
      const chunkRMS = getRMS(chunk);
      const noiseFactor = Math.max(0, 1 - (noiseRMS / chunkRMS));
      
      for (let j = 0; j < chunk.length; j++) {
        const noiseIndex = j % noiseProfile.length;
        cleanedSignal[start + j] = chunk[j] - (noiseProfile[noiseIndex] * noiseFactor * 0.7);
      }
    }
    
    return cleanedSignal;
  }

  async function recordAudio(seconds, onDone, recordNoise = false) {
    if (!hasMicrophoneAccess) {
      const accessGranted = await requestMicrophoneAccess();
      if (!accessGranted) return;
    }

    if (isRecording) await stopRecording();

    try {
      setStatus('üîç –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∑–∞–ø–∏—Å–∏...');
      audioData = [];
      isRecording = true;
      setButtonsDisabled(true);

      currentStream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          sampleRate: 44100
        }
      });
      
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      await audioContext.resume();

      sourceNode = audioContext.createMediaStreamSource(currentStream);
      
      if (recordNoise) {
        await recordNoiseProfile(NOISE_RECORD_DURATION);
      }
      
      scriptProcessor = audioContext.createScriptProcessor(CHUNK_SIZE, 1, 1);
      scriptProcessor.onaudioprocess = (event) => {
        const input = event.inputBuffer.getChannelData(0);
        audioData.push(...input);
      };

      sourceNode.connect(scriptProcessor);
      scriptProcessor.connect(audioContext.destination);

      setStatus('üé§ –ò–¥—ë—Ç –∑–∞–ø–∏—Å—å...');

      recordTimer = setTimeout(async () => {
        await stopRecording();
        if (typeof onDone === 'function') onDone();
      }, Math.max(0, seconds * 1000));

    } catch (err) {
      console.error('–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏:', err);
      setStatus('–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏: ' + (err.message || err), 'error');
      await stopRecording();
    }
  }

  async function stopRecording() {
    if (!isRecording) return;
    isRecording = false;
    try {
      if (recordTimer) { clearTimeout(recordTimer); recordTimer = null; }
      if (scriptProcessor) { 
        scriptProcessor.disconnect(); 
        scriptProcessor.onaudioprocess = null; 
      }
      if (sourceNode) { sourceNode.disconnect(); }
      if (currentStream) {
        currentStream.getTracks().forEach(track => {
          track.stop();
          track.enabled = false;
        });
      }
      if (audioContext) {
        await audioContext.close();
        audioContext = null;
      }
    } catch (e) {
      console.warn('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –∑–∞–ø–∏—Å–∏:', e);
    } finally {
      scriptProcessor = null;
      sourceNode = null;
      currentStream = null;
      setButtonsDisabled(false);
    }
  }

  calibrateBtn.addEventListener('click', async () => {
    const accessGranted = await requestMicrophoneAccess();
    if (!accessGranted) return;
    
    alert('–°–∫–∞–∂–∏—Ç–µ —á—Ç–æ-—Ç–æ –≤—Å–ª—É—Ö –∏–ª–∏ —Ö–ª–æ–ø–Ω–∏—Ç–µ –≤ –ª–∞–¥–æ—à–∏ –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ ~30 —Å–º –æ—Ç –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞.\n–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –¥–ª–∏—Ç—Å—è 3 —Å–µ–∫—É–Ω–¥—ã.');
    await recordAudio(3, () => {
      const cleanedData = denoiseSignal(audioData);
      const rms = getRMS(cleanedData);
      
      if (!rms || rms <= 1e-6) {
        setStatus('‚ö† –û—á–µ–Ω—å –Ω–∏–∑–∫–∏–π —Å–∏–≥–Ω–∞–ª –≤–æ –≤—Ä–µ–º—è –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ.', 'error');
        return;
      }
      
      const L_ref = 65;
      const P_ref = 20e-6 * Math.pow(10, L_ref / 20);
      K = P_ref / rms;
      localStorage.setItem('calibrationK', String(K));
      setStatus(`‚úÖ –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. K = ${K.toExponential(3)} –ü–∞/–µ–¥.`, 'ok');
    }, true);
  });

  resetCalBtn.addEventListener('click', () => {
    localStorage.removeItem('calibrationK');
    K = NaN;
    noiseProfile = [];
    noiseRMS = 0;
    setStatus('–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ —Å–±—Ä–æ—à–µ–Ω–∞. –í—ã–ø–æ–ª–Ω–∏—Ç–µ ¬´–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞¬ª –ø–µ—Ä–µ–¥ –∏–∑–º–µ—Ä–µ–Ω–∏–µ–º.', '');
  });

  startBtn.addEventListener('click', async () => {
    if (!isFinite(K) || K <= 0) {
      alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∫–∞–ª–∏–±—Ä–æ–≤–∫—É.');
      return;
    }
    await recordAudio(DURATION, processAudio, true);
  });

  function processAudio() {
    if (!audioData || audioData.length === 0) {
      setStatus('‚ùå –ó–≤—É–∫ –Ω–µ –∑–∞–ø–∏—Å–∞–Ω.', 'error');
      return;
    }
    
    setStatus('üîß –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏ –æ—á–∏—Å—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–∞...', 'processing');
    
    setTimeout(() => {
      const cleanedData = denoiseSignal(audioData);
      
      const dbValues = [];
      for (let i = 0; i < cleanedData.length; i += CHUNK_SIZE) {
        const chunk = cleanedData.slice(i, i + CHUNK_SIZE);
        const rms = getRMS(chunk);
        const P = Math.max(rms * K, 1e-12);
        const dB = 20 * Math.log10(P / 20e-6);
        dbValues.push(dB);
      }
      
      drawGraph(dbValues);
      setStatus('‚úÖ –ì—Ä–∞—Ñ–∏–∫ –ø–æ—Å—Ç—Ä–æ–µ–Ω! –°–∏–≥–Ω–∞–ª –æ—á–∏—â–µ–Ω –æ—Ç —à—É–º–∞.', 'ok');
    }, 100);
  }

  function drawGraph(dbValues) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let maxDb = Math.max(...dbValues);
    let minDb = 0;
    if (!isFinite(maxDb)) { maxDb = 100; }
    const padding = 5;
    maxDb = Math.ceil((maxDb + padding) / 5) * 5;

    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid') || '#e5e7eb';
    ctx.lineWidth = 1;
    ctx.font = '12px Arial';
    ctx.fillStyle = '#555';
    for (let db = 0; db <= maxDb; db += 10) {
      const y = mapDbToY(db, minDb, maxDb);
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
      ctx.fillText(db + ' –¥–ë', 6, y - 2);
    }

    const N = dbValues.length;
    for (let t = 0; t <= DURATION; t++) {
      const x = (t / DURATION) * canvas.width;
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
      ctx.fillText(t + ' —Å', x + 3, canvas.height - 6);
    }

    ctx.beginPath();
    const denom = Math.max(1, N - 1);
    for (let i = 0; i < N; i++) {
      const x = (i / denom) * canvas.width;
      const y = mapDbToY(dbValues[i], minDb, maxDb);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--blue') || '#2563eb';
    ctx.lineWidth = 2; ctx.stroke();

    ctx.strokeStyle = '#000';
    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, canvas.height);
    ctx.moveTo(0, canvas.height); ctx.lineTo(canvas.width, canvas.height); ctx.stroke();

    ctx.font = '14px Arial'; ctx.fillStyle = '#000';
    ctx.fillText('–í—Ä–µ–º—è (—Å)', canvas.width / 2 - 35, canvas.height - 10);
    ctx.save(); ctx.rotate(-Math.PI / 2);
    ctx.fillText('–£—Ä–æ–≤–µ–Ω—å –∑–≤—É–∫–∞ (–¥–ë SPL)', -canvas.height / 2 - 55, 15);
    ctx.restore();
  }

  function mapDbToY(value, minDb, maxDb) {
    const frac = (value - minDb) / (maxDb - minDb);
    return canvas.height - frac * canvas.height;
  }

  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–æ—Å—Ç—É–ø –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
  window.addEventListener('load', () => {
    setTimeout(() => {
      requestMicrophoneAccess();
    }, 1000);
  });

  window.addEventListener('beforeunload', () => { 
    if (isRecording) stopRecording(); 
  });
})();
</script>
</body>
</html>