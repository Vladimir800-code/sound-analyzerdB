<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>–ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∑–≤—É–∫–∞ (–í—Ç/–º¬≤) –∏ —Ä–∞—Å—Ö–æ–¥–∞ –≤–æ–∑–¥—É—Ö–∞</title>
<style>
  :root { --blue:#2563eb; --blue-dark:#1e40af; --grid:#e5e7eb; --text:#111827; --muted:#6b7280; --green:#10b981; --green-dark:#059669; --orange:#f97316; --orange-dark:#ea580c; }
  * { box-sizing: border-box; }
  body {
    font-family: Arial, sans-serif;
    color: var(--text);
    background: linear-gradient(to bottom, #f0f4f8, #dbeafe);
    margin: 0; padding: 0; text-align: center;
  }
  header { padding: 18px 12px 6px; }
  h1 { margin: 0 0 8px; color:#1e3a8a; font-size: 22px; }
  .controls { margin: 8px 0 4px; display:flex; gap:8px; justify-content:center; flex-wrap: wrap; }
  button {
    padding: 10px 16px; font-size: 15px; border: none; border-radius: 10px;
    background: var(--blue); color:#fff; cursor:pointer; transition: background .25s ease, transform .05s ease;
  }
  button:hover { background: var(--blue-dark); }
  button:active { transform: translateY(1px); }
  button:disabled { background:#94a3b8; cursor: not-allowed; }
  #status { min-height: 22px; font-weight: 600; margin: 8px 0 0; color:#0f172a; }
  #status.error { color:#b91c1c; }
  #status.ok { color:#065f46; }
  #status.processing { color:#1e40af; }
  main { padding: 10px 12px 30px; }
  canvas {
    display:block; margin: 12px auto 0; background:#fff; border:1px solid #000;
    max-width: 95vw; height:auto;
  }
  .hint { color: var(--muted); font-size: 13px; margin-top: 6px; }
  .permission-note {
    background: #fffbeb;
    border: 1px solid #fcd34d;
    border-radius: 8px;
    padding: 12px;
    margin: 12px auto;
    max-width: 500px;
    font-size: 14px;
    color: #92400e;
  }
  .legend {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    margin-top: 15px;
    font-size: 14px;
    background: #f8fafc;
    border-radius: 8px;
    padding: 12px;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
  }
  .legend-row {
    display: flex;
    justify-content: center;
    gap: 20px;
    flex-wrap: wrap;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .legend-color {
    width: 20px;
    height: 3px;
    display: inline-block;
  }
  .signal-info {
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px dashed #cbd5e1;
    width: 100%;
  }
  .signal-info-item {
    display: flex;
    justify-content: space-between;
    margin: 4px 0;
  }
  .signal-info-label {
    font-weight: bold;
    color: var(--muted);
  }
  .signal-info-value {
    font-weight: 600;
    color: var(--text);
  }
  .input-group {
    margin: 10px 0;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    flex-wrap: wrap;
  }
  .input-group label {
    font-weight: bold;
    color: var(--muted);
  }
  .input-group input {
    padding: 8px 12px;
    border: 1px solid #cbd5e1;
    border-radius: 6px;
    font-size: 14px;
    width: 120px;
    text-align: center;
  }
</style>
</head>
<body>
<header>
  <h1>–ê–Ω–∞–ª–∏–∑ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏ –∑–≤—É–∫–∞ –∏ —Ä–∞—Å—Ö–æ–¥–∞ –≤–æ–∑–¥—É—Ö–∞</h1>
  <div class="permission-note">
    ‚ö† –î–ª—è —Ä–∞–±–æ—Ç—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É.<br>
    –†–∞–∑—Ä–µ—à–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –≤ –±—Ä–∞—É–∑–µ—Ä–µ.
  </div>
  
  <div class="input-group">
    <label for="flowCoefficient">–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è:</label>
    <input type="number" id="flowCoefficient" value="10000" min="100" max="20000" step="100">
    <span>–ª/—Å –Ω–∞ –í—Ç/–º¬≤</span>
  </div>
  
  <div class="controls">
    <button id="calibrateBtn">üìè –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞</button>
    <button id="startBtn">üéô –ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å (10 —Å)</button>
    <button id="resetCalBtn" title="–£–¥–∞–ª–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—É—é –∫–∞–ª–∏–±—Ä–æ–≤–∫—É">‚ôªÔ∏è –°–±—Ä–æ—Å –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏</button>
  </div>
  <div id="status" aria-live="polite"></div>
  <div class="hint">–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ ¬´–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞¬ª. –í–∞—à–∞ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –±—Ä–∞—É–∑–µ—Ä–µ (localStorage).</div>
</header>
<main>
  <canvas id="graph" width="900" height="420"></canvas>
  <div class="legend">
    <div class="legend-row">
      <div class="legend-item">
        <span class="legend-color" style="background: var(--blue);"></span>
        <span>–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –∑–≤—É–∫–∞ (–í—Ç/–º¬≤)</span>
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background: var(--green);"></span>
        <span>–ò–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è (–í—Ç¬∑—Å/–º¬≤)</span>
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background: var(--orange);"></span>
        <span>–ò–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω—ã–π —Ä–∞—Å—Ö–æ–¥ –≤–æ–∑–¥—É—Ö–∞ (–ª)</span>
      </div>
    </div>
    <div class="signal-info" id="signalInfo" style="display: none;">
      <div class="signal-info-item">
        <span class="signal-info-label">–ù–∞—á–∞–ª–æ —Å–∏–≥–Ω–∞–ª–∞:</span>
        <span class="signal-info-value" id="startTime">-</span>
      </div>
      <div class="signal-info-item">
        <span class="signal-info-label">–ö–æ–Ω–µ—Ü —Å–∏–≥–Ω–∞–ª–∞:</span>
        <span class="signal-info-value" id="endTime">-</span>
      </div>
      <div class="signal-info-item">
        <span class="signal-info-label">–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–∏–≥–Ω–∞–ª–∞:</span>
        <span class="signal-info-value" id="duration">-</span>
      </div>
      <div class="signal-info-item">
        <span class="signal-info-label">–°—Ä–µ–¥–Ω—è—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å:</span>
        <span class="signal-info-value" id="avgIntensity">-</span>
      </div>
      <div class="signal-info-item">
        <span class="signal-info-label">–ù–∞–∫–æ–ø–ª–µ–Ω–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è:</span>
        <span class="signal-info-value" id="totalEnergy">-</span>
      </div>
      <div class="signal-info-item">
        <span class="signal-info-label">–ú–∞–∫—Å. —Ä–∞—Å—Ö–æ–¥ –≤–æ–∑–¥—É—Ö–∞:</span>
        <span class="signal-info-value" id="maxFlowRate">-</span>
      </div>
      <div class="signal-info-item">
        <span class="signal-info-label">–°—Ä–µ–¥–Ω–∏–π —Ä–∞—Å—Ö–æ–¥:</span>
        <span class="signal-info-value" id="avgFlowRate">-</span>
      </div>
      <div class="signal-info-item">
        <span class="signal-info-label">–û–±—â–∏–π –æ–±—ä–µ–º –≤–æ–∑–¥—É—Ö–∞:</span>
        <span class="signal-info-value" id="totalVolume">-</span>
      </div>
    </div>
  </div>
</main>

<script>
(() => {
  const startBtn = document.getElementById('startBtn');
  const calibrateBtn = document.getElementById('calibrateBtn');
  const resetCalBtn = document.getElementById('resetCalBtn');
  const flowCoefficientInput = document.getElementById('flowCoefficient');
  const status = document.getElementById('status');
  const canvas = document.getElementById('graph');
  const ctx = canvas.getContext('2d');
  
  // –≠–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–∏–≥–Ω–∞–ª–µ
  const signalInfo = document.getElementById('signalInfo');
  const startTimeEl = document.getElementById('startTime');
  const endTimeEl = document.getElementById('endTime');
  const durationEl = document.getElementById('duration');
  const avgIntensityEl = document.getElementById('avgIntensity');
  const totalEnergyEl = document.getElementById('totalEnergy');
  const maxFlowRateEl = document.getElementById('maxFlowRate');
  const avgFlowRateEl = document.getElementById('avgFlowRate');
  const totalVolumeEl = document.getElementById('totalVolume');

  const DURATION = 10;
  const CHUNK_SIZE = 1024;
  const NOISE_RECORD_DURATION = 2;
  const INTEGRAL_SCALE = 1;
  let audioData = [];
  let noiseProfile = [];
  let noiseRMS = 0;
  
  // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–∏–≥–Ω–∞–ª–µ
  let signalStartTime = 0;
  let signalEndTime = 0;
  let signalDuration = 0;
  let averageIntensity = 0;
  let totalEnergyValue = 0;
  let maxFlowRateValue = 0;
  let averageFlowRateValue = 0;
  let totalVolumeValue = 0;

  let audioContext = null;
  let sourceNode = null;
  let scriptProcessor = null;
  let currentStream = null;
  let recordTimer = null;
  let isRecording = false;
  let hasMicrophoneAccess = false;

  let K = parseFloat(localStorage.getItem('calibrationK') || 'NaN');
  if (isFinite(K) && K > 0) {
    setStatus('–ù–∞–π–¥–µ–Ω–∞ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–∞—è –∫–∞–ª–∏–±—Ä–æ–≤–∫–∞.', 'ok');
  } else {
    K = NaN;
    setStatus('–ù–∞–∂–º–∏—Ç–µ "–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞" –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã.', '');
  }

  function setStatus(text, cls='') {
    status.className = cls ? cls : '';
    status.textContent = text;
  }

  function setButtonsDisabled(disabled) {
    startBtn.disabled = disabled;
    calibrateBtn.disabled = disabled;
    resetCalBtn.disabled = disabled && !isFinite(K);
  }

  function getRMS(arr) {
    if (!arr || arr.length === 0) return 0;
    let s = 0;
    for (let i = 0; i < arr.length; i++) s += arr[i] * arr[i];
    return Math.sqrt(s / arr.length);
  }

  // –§—É–Ω–∫—Ü–∏—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏ –≤ —Ä–∞—Å—Ö–æ–¥ –≤–æ–∑–¥—É—Ö–∞
  function intensityToFlowRate(intensity) {
    const k = parseFloat(flowCoefficientInput.value) || 10000;
    return intensity * k; // Y = kX
  }

  async function requestMicrophoneAccess() {
    if (hasMicrophoneAccess) return true;
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      setStatus('‚ùå –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä–∞–±–æ—Ç—É —Å –º–∏–∫—Ä–æ—Ñ–æ–Ω–æ–º.', 'error');
      return false;
    }
    try {
      setStatus('üîç –ó–∞–ø—Ä–æ—Å –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É...', 'processing');
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      currentStream = stream;
      hasMicrophoneAccess = true;
      setStatus('‚úÖ –î–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –ø–æ–ª—É—á–µ–Ω', 'ok');
      return true;
    } catch (error) {
      setStatus('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É: ' + error.message, 'error');
      return false;
    }
  }

  async function recordNoiseProfile(duration) {
    return new Promise((resolve) => {
      setStatus('üîç –ó–∞–ø–∏—Å—å —Ñ–æ–Ω–æ–≤–æ–≥–æ —à—É–º–∞...', 'processing');
      const noiseData = [];
      const tempScriptProcessor = audioContext.createScriptProcessor(CHUNK_SIZE, 1, 1);
      tempScriptProcessor.onaudioprocess = (event) => {
        const input = event.inputBuffer.getChannelData(0);
        noiseData.push(...input);
      };
      sourceNode.connect(tempScriptProcessor);
      tempScriptProcessor.connect(audioContext.destination);
      setTimeout(() => {
        tempScriptProcessor.disconnect();
        tempScriptProcessor.onaudioprocess = null;
        noiseRMS = getRMS(noiseData);
        noiseProfile = new Array(CHUNK_SIZE).fill(0);
        setStatus('‚úÖ –ü—Ä–æ—Ñ–∏–ª—å —à—É–º–∞ –∑–∞–ø–∏—Å–∞–Ω', 'ok');
        resolve();
      }, duration * 1000);
    });
  }

  function denoiseSignal(signal) {
    if (!noiseProfile.length || noiseRMS < 1e-6) return signal;
    return signal;
  }

  function detectSignalStartEnd(signal, noiseThreshold = 3.0) {
    const chunkRMS = [];
    for (let i = 0; i < signal.length; i += CHUNK_SIZE) {
      const chunk = signal.slice(i, i + CHUNK_SIZE);
      chunkRMS.push(getRMS(chunk));
    }
    
    const threshold = noiseThreshold * noiseRMS;
    
    let startIndex = -1;
    for (let i = 0; i < chunkRMS.length; i++) {
      if (chunkRMS[i] > threshold) {
        startIndex = i;
        break;
      }
    }
    
    let endIndex = -1;
    for (let i = chunkRMS.length - 1; i >= 0; i--) {
      if (chunkRMS[i] > threshold) {
        endIndex = i;
        break;
      }
    }
    
    if (startIndex === -1 || endIndex === -1) {
      signalStartTime = 0;
      signalEndTime = 0;
      signalDuration = 0;
      return signal;
    }
    
    signalStartTime = (startIndex * CHUNK_SIZE / signal.length) * DURATION;
    signalEndTime = (endIndex * CHUNK_SIZE / signal.length) * DURATION;
    signalDuration = signalEndTime - signalStartTime;
    
    const newSignal = new Array(signal.length).fill(0);
    const startSample = startIndex * CHUNK_SIZE;
    const endSample = Math.min((endIndex + 1) * CHUNK_SIZE, signal.length);
    
    for (let i = startSample; i < endSample; i++) {
      newSignal[i] = signal[i];
    }
    
    return newSignal;
  }

  function calculateIntegralCurve(intensityValues) {
    if (!intensityValues || intensityValues.length === 0) return [];
    
    const integralValues = [];
    let cumulativeSum = 0;
    const timeStep = DURATION / intensityValues.length;
    
    for (let i = 0; i < intensityValues.length; i++) {
      cumulativeSum += intensityValues[i] * timeStep;
      integralValues.push(cumulativeSum);
    }
    
    totalEnergyValue = cumulativeSum;
    return integralValues;
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–æ–π –∫—Ä–∏–≤–æ–π —Ä–∞—Å—Ö–æ–¥–∞ –≤–æ–∑–¥—É—Ö–∞ (–ª–∏—Ç—Ä—ã)
  function calculateFlowIntegralCurve(intensityValues) {
    if (!intensityValues || intensityValues.length === 0) return [];
    
    const flowIntegralValues = [];
    let cumulativeVolume = 0;
    const timeStep = DURATION / intensityValues.length;
    
    for (let i = 0; i < intensityValues.length; i++) {
      const flowRate = intensityToFlowRate(intensityValues[i]);
      cumulativeVolume += flowRate * timeStep;
      flowIntegralValues.push(cumulativeVolume);
    }
    
    totalVolumeValue = cumulativeVolume;
    return flowIntegralValues;
  }

  function calculateAverageIntensity(intensityValues) {
    if (!intensityValues || intensityValues.length === 0) return 0;
    
    const startChunk = Math.floor((signalStartTime / DURATION) * intensityValues.length);
    const endChunk = Math.floor((signalEndTime / DURATION) * intensityValues.length);
    
    if (startChunk >= endChunk) return 0;
    
    let sum = 0;
    let count = 0;
    for (let i = startChunk; i <= endChunk && i < intensityValues.length; i++) {
      sum += intensityValues[i];
      count++;
    }
    
    return count > 0 ? sum / count : 0;
  }

  // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø–æ—Ç–æ–∫–∞ –≤–æ–∑–¥—É—Ö–∞
  function calculateFlowParameters(intensityValues) {
    if (!intensityValues || intensityValues.length === 0) return;
    
    const flowRateValues = intensityValues.map(intensityToFlowRate);
    const timeStep = DURATION / intensityValues.length;
    
    // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞—Å—Ö–æ–¥
    maxFlowRateValue = Math.max(...flowRateValues);
    
    // –°—Ä–µ–¥–Ω–∏–π —Ä–∞—Å—Ö–æ–¥ –≤ —Ç–µ—á–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞
    const startChunk = Math.floor((signalStartTime / DURATION) * intensityValues.length);
    const endChunk = Math.floor((signalEndTime / DURATION) * intensityValues.length);
    
    if (startChunk >= endChunk) return;
    
    let flowSum = 0;
    let count = 0;
    for (let i = startChunk; i <= endChunk && i < flowRateValues.length; i++) {
      flowSum += flowRateValues[i];
      count++;
    }
    
    averageFlowRateValue = count > 0 ? flowSum / count : 0;
  }

  async function recordAudio(seconds, onDone, recordNoise = false) {
    if (!hasMicrophoneAccess) {
      const accessGranted = await requestMicrophoneAccess();
      if (!accessGranted) return;
    }
    if (isRecording) await stopRecording();
    try {
      audioData = [];
      isRecording = true;
      setButtonsDisabled(true);
      
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      await audioContext.resume();
      sourceNode = audioContext.createMediaStreamSource(currentStream);
      
      if (recordNoise) await recordNoiseProfile(NOISE_RECORD_DURATION);
      scriptProcessor = audioContext.createScriptProcessor(CHUNK_SIZE, 1, 1);
      scriptProcessor.onaudioprocess = (event) => {
        const input = event.inputBuffer.getChannelData(0);
        audioData.push(...input);
      };
      sourceNode.connect(scriptProcessor);
      scriptProcessor.connect(audioContext.destination);
      setStatus('üé§ –ò–¥—ë—Ç –∑–∞–ø–∏—Å—å...');
      recordTimer = setTimeout(async () => {
        await stopRecording();
        if (typeof onDone === 'function') onDone();
      }, Math.max(0, seconds * 1000));
    } catch (err) {
      setStatus('–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏: ' + (err.message || err), 'error');
      await stopRecording();
    }
  }

  async function stopRecording() {
    if (!isRecording) return;
    isRecording = false;
    try {
      if (recordTimer) clearTimeout(recordTimer);
      if (scriptProcessor) { scriptProcessor.disconnect(); scriptProcessor.onaudioprocess = null; }
      if (sourceNode) sourceNode.disconnect();
      if (audioContext) await audioContext.close();
    } finally {
      scriptProcessor = null; sourceNode = null;
      setButtonsDisabled(false);
    }
  }

  calibrateBtn.addEventListener('click', async () => {
    const accessGranted = await requestMicrophoneAccess();
    if (!accessGranted) return;
    alert('–°–∫–∞–∂–∏—Ç–µ —á—Ç–æ-—Ç–æ –≤—Å–ª—É—Ö –∏–ª–∏ —Ö–ª–æ–ø–Ω–∏—Ç–µ –≤ –ª–∞–¥–æ—à–∏ (3 —Å–µ–∫—É–Ω–¥—ã).');
    await recordAudio(3, () => {
      const cleanedData = denoiseSignal(audioData);
      const rms = getRMS(cleanedData);
      if (!rms || rms <= 1e-6) {
        setStatus('‚ö† –°–ª–∞–±—ã–π —Å–∏–≥–Ω–∞–ª. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ.', 'error');
        return;
      }
      const L_ref = 65;
      const P_ref = 20e-6 * Math.pow(10, L_ref / 20);
      K = P_ref / rms;
      localStorage.setItem('calibrationK', String(K));
      setStatus(`‚úÖ –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. K = ${K.toExponential(3)} –ü–∞/–µ–¥.`, 'ok');
    }, true);
  });

  resetCalBtn.addEventListener('click', () => {
    localStorage.removeItem('calibrationK');
    K = NaN; noiseProfile = []; noiseRMS = 0;
    setStatus('–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ —Å–±—Ä–æ—à–µ–Ω–∞.', '');
  });

  startBtn.addEventListener('click', async () => {
    if (!isFinite(K) || K <= 0) {
      alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –∫–∞–ª–∏–±—Ä–æ–≤–∫—É.');
      return;
    }
    await recordAudio(DURATION, processAudio, true);
  });

  function processAudio() {
    if (!audioData || audioData.length === 0) {
      setStatus('‚ùå –ó–≤—É–∫ –Ω–µ –∑–∞–ø–∏—Å–∞–Ω.', 'error');
      return;
    }
    setStatus('üîß –û–±—Ä–∞–±–æ—Ç–∫–∞...', 'processing');
    setTimeout(() => {
      const signalWithDetectedEdges = detectSignalStartEnd(audioData);
      const cleanedData = denoiseSignal(signalWithDetectedEdges);
      
      const intensityValues = [];
      const rho = 1.21, c = 343;
      for (let i = 0; i < cleanedData.length; i += CHUNK_SIZE) {
        const chunk = cleanedData.slice(i, i + CHUNK_SIZE);
        const rms = getRMS(chunk);
        const P = Math.max(rms * K, 1e-12);
        const I = (P * P) / (rho * c);
        intensityValues.push(I);
      }
      
      const integralValues = calculateIntegralCurve(intensityValues);
      const flowIntegralValues = calculateFlowIntegralCurve(intensityValues);
      averageIntensity = calculateAverageIntensity(intensityValues);
      calculateFlowParameters(intensityValues);
      
      updateSignalInfo();
      drawGraph(intensityValues, integralValues, flowIntegralValues);
      setStatus('‚úÖ –ì—Ä–∞—Ñ–∏–∫ –ø–æ—Å—Ç—Ä–æ–µ–Ω! –î–æ–±–∞–≤–ª–µ–Ω–∞ –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–∞—è –∫—Ä–∏–≤–∞—è —Ä–∞—Å—Ö–æ–¥–∞ –≤–æ–∑–¥—É—Ö–∞.', 'ok');
    }, 100);
  }

  function updateSignalInfo() {
    signalInfo.style.display = 'block';
    
    startTimeEl.textContent = signalStartTime.toFixed(2) + ' —Å–µ–∫';
    endTimeEl.textContent = signalEndTime.toFixed(2) + ' —Å–µ–∫';
    durationEl.textContent = signalDuration.toFixed(2) + ' —Å–µ–∫';
    avgIntensityEl.textContent = averageIntensity.toExponential(2) + ' –í—Ç/–º¬≤';
    totalEnergyEl.textContent = totalEnergyValue.toFixed(4) + ' –í—Ç¬∑—Å/–º¬≤';
    maxFlowRateEl.textContent = maxFlowRateValue.toFixed(2) + ' –ª/—Å';
    avgFlowRateEl.textContent = averageFlowRateValue.toFixed(2) + ' –ª/—Å';
    totalVolumeEl.textContent = totalVolumeValue.toFixed(2) + ' –ª';
  }

  function drawGraph(intensityValues, integralValues, flowIntegralValues) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
    let maxIntensity = Math.max(...intensityValues);
    if (!isFinite(maxIntensity) || maxIntensity <= 0) maxIntensity = 1;
    
    let maxIntegral = integralValues && integralValues.length > 0 ? Math.max(...integralValues) : 0;
    if (!isFinite(maxIntegral)) maxIntegral = 0;
    
    let maxFlowIntegral = flowIntegralValues && flowIntegralValues.length > 0 ? Math.max(...flowIntegralValues) : 0;
    if (!isFinite(maxFlowIntegral) || maxFlowIntegral <= 0) maxFlowIntegral = 1;
    
    const scaledIntegralValues = integralValues.map(val => val);
    const maxScaledIntegral = maxIntegral;
    
    const maxIntensityForScale = maxIntensity * 1.05;
    const maxIntegralForScale = maxScaledIntegral * 1.1;
    const maxFlowIntegralForScale = maxFlowIntegral * 1.1;
    
    // –°–µ—Ç–∫–∞ –¥–ª—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
    ctx.lineWidth = 1;
    const intensitySteps = 5;
    for (let i = 0; i <= intensitySteps; i++) {
      const val = (maxIntensityForScale / intensitySteps) * i;
      const y = mapValToY(val, 0, maxIntensityForScale);
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
    
    // –õ–µ–≤–∞—è —à–∫–∞–ª–∞ - –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å
    ctx.font = '10px Arial';
    ctx.fillStyle = '#555';
    ctx.textAlign = 'left';
    for (let i = 0; i <= intensitySteps; i++) {
      const val = (maxIntensityForScale / intensitySteps) * i;
      const y = mapValToY(val, 0, maxIntensityForScale);
      ctx.fillText(val.toExponential(2) + ' –í—Ç/–º¬≤', 6, y - 2);
    }
    
    // –ü—Ä–∞–≤–∞—è —à–∫–∞–ª–∞ - –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è
    ctx.textAlign = 'right';
    const integralSteps = 5;
    for (let i = 0; i <= integralSteps; i++) {
      const val = (maxIntegralForScale / integralSteps) * i;
      const y = mapValToY(val, 0, maxIntensityForScale);
      ctx.fillText(val.toExponential(2) + ' –í—Ç¬∑—Å/–º¬≤', canvas.width - 6, y - 2);
    }
    
    // –¢—Ä–µ—Ç—å—è —à–∫–∞–ª–∞ —Å–ø—Ä–∞–≤–∞ - –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω—ã–π —Ä–∞—Å—Ö–æ–¥ (–ª–∏—Ç—Ä—ã)
    ctx.textAlign = 'right';
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--orange-dark');
    const flowIntegralSteps = 5;
    for (let i = 0; i <= flowIntegralSteps; i++) {
      const val = (maxFlowIntegralForScale / flowIntegralSteps) * i;
      const y = mapValToY(val, 0, maxIntensityForScale);
      ctx.fillText(val.toFixed(1) + ' –ª', canvas.width - 100, y - 2);
    }
    ctx.textAlign = 'left';
    
    // –í—Ä–µ–º–µ–Ω–Ω–∞—è —Å–µ—Ç–∫–∞
    for (let t = 0; t <= DURATION; t++) {
      const x = (t / DURATION) * canvas.width;
      ctx.beginPath(); 
      ctx.moveTo(x, 0); 
      ctx.lineTo(x, canvas.height); 
      ctx.stroke();
      ctx.fillStyle = '#555';
      ctx.fillText(t + ' —Å', x + 3, canvas.height - 6);
    }
    
    // –ì—Ä–∞—Ñ–∏–∫ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏
    ctx.beginPath();
    const N = intensityValues.length;
    const denom = Math.max(1, N - 1);
    for (let i = 0; i < N; i++) {
      const x = (i / denom) * canvas.width;
      const y = mapValToY(intensityValues[i], 0, maxIntensityForScale);
      if (i === 0) ctx.moveTo(x, y); 
      else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--blue');
    ctx.lineWidth = 2; 
    ctx.stroke();
    
    // –ì—Ä–∞—Ñ–∏–∫ –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–æ–π —ç–Ω–µ—Ä–≥–∏–∏
    if (scaledIntegralValues && scaledIntegralValues.length > 0) {
      ctx.beginPath();
      for (let i = 0; i < scaledIntegralValues.length; i++) {
        const x = (i / denom) * canvas.width;
        const scaledY = mapValToY(scaledIntegralValues[i], 0, maxIntensityForScale);
        if (i === 0) ctx.moveTo(x, scaledY); 
        else ctx.lineTo(x, scaledY);
      }
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--green');
      ctx.lineWidth = 2; 
      ctx.stroke();
      
      if (scaledIntegralValues.length > 1) {
        const lastValue = scaledIntegralValues[scaledIntegralValues.length - 1];
        const y = mapValToY(lastValue, 0, maxIntensityForScale);
        ctx.beginPath();
        ctx.setLineDash([5, 3]);
        ctx.moveTo((scaledIntegralValues.length - 1) / denom * canvas.width, y);
        ctx.lineTo(canvas.width, y);
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--green-dark');
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
    
    // –ì—Ä–∞—Ñ–∏–∫ –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å—Ö–æ–¥–∞ –≤–æ–∑–¥—É—Ö–∞ (–ª–∏—Ç—Ä—ã)
    if (flowIntegralValues && flowIntegralValues.length > 0) {
      ctx.beginPath();
      for (let i = 0; i < flowIntegralValues.length; i++) {
        const x = (i / denom) * canvas.width;
        // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω—ã–π —Ä–∞—Å—Ö–æ–¥ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ —Ç–æ–π –∂–µ —à–∫–∞–ª–µ
        const scaledFlowIntegral = flowIntegralValues[i] * (maxIntensityForScale / maxFlowIntegralForScale);
        const y = mapValToY(scaledFlowIntegral, 0, maxIntensityForScale);
        if (i === 0) ctx.moveTo(x, y); 
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--orange');
      ctx.lineWidth = 2; 
      ctx.stroke();
      
      // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –∞—Å–∏–º–ø—Ç–æ—Ç–∞ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å—Ö–æ–¥–∞
      if (flowIntegralValues.length > 1) {
        const lastValue = flowIntegralValues[flowIntegralValues.length - 1];
        const scaledLastValue = lastValue * (maxIntensityForScale / maxFlowIntegralForScale);
        const y = mapValToY(scaledLastValue, 0, maxIntensityForScale);
        ctx.beginPath();
        ctx.setLineDash([5, 3]);
        ctx.moveTo((flowIntegralValues.length - 1) / denom * canvas.width, y);
        ctx.lineTo(canvas.width, y);
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--orange-dark');
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }
    
    // –û—Å–∏
    ctx.strokeStyle = '#000';
    ctx.beginPath(); 
    ctx.moveTo(0, 0); 
    ctx.lineTo(0, canvas.height);
    ctx.moveTo(0, canvas.height); 
    ctx.lineTo(canvas.width, canvas.height); 
    ctx.stroke();
    
    // –ü–æ–¥–ø–∏—Å–∏ –æ—Å–µ–π
    ctx.font = '14px Arial'; 
    ctx.fillStyle = '#000';
    ctx.fillText('–í—Ä–µ–º—è (—Å)', canvas.width / 2 - 35, canvas.height - 10);
    ctx.save(); 
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('–ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –∑–≤—É–∫–∞ (–í—Ç/–º¬≤)', -canvas.height / 2 - 55, 15);
    ctx.restore();
    
    // –ü–æ–¥–ø–∏—Å—å –ø—Ä–∞–≤–æ–π —à–∫–∞–ª—ã
    ctx.save();
    ctx.rotate(Math.PI / 2);
    ctx.fillText('–≠–Ω–µ—Ä–≥–∏—è (–í—Ç¬∑—Å/–º¬≤)', canvas.height / 2 - 60, canvas.width - 10);
    ctx.restore();
  }

  function mapValToY(value, minVal, maxVal) {
    const frac = (value - minVal) / (maxVal - minVal);
    return canvas.height - frac * canvas.height;
  }

  window.addEventListener('load', () => {
    setTimeout(() => { requestMicrophoneAccess(); }, 1000);
  });
})();
</script>
</body>
</html>